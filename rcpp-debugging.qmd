# Debugging R w C++/C code

Although debugging R code is easy, the same doesn't apply to compiled code in R[^debug-vscode]. This chapter shows a few ways to debug your R + C++ code. You will need the [GNU Debugger (GDB)](https://en.wikipedia.org/w/index.php?title=GNU_Debugger&oldid=1146565095){target="_blank"} and [Valgrind](https://en.wikipedia.org/w/index.php?title=Valgrind&oldid=1135729346){target="_blank"}.

[^debug-vscode]: Debugging **only** C++/C code is easy, though. If you already work with compiled code, you must be aware of [VS Code](https://code.visualstudio.com/){target="_blank"} and the many other tools out there for debugging C++/C code.

## Starting R with a debugger

We must launch the program through the command line to use a debugger within R. To lunch R with Valgrind, we use the following:

```bash
$ R --debugger=valgrind
```

Which will result in something like the following:

```bash
==31245== Memcheck, a memory error detector
==31245== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==31245== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==31245== Command: /usr/lib/R/bin/exec/R
==31245== 

R version 4.2.3 (2023-03-15) -- "Shortstop Beagle"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> 
```

Once R executes with Valgrind, the debugger will catch any memory leaks generated by your C++/C code. The following is a faulty Rcpp program that creates a pointer using `new` and "forgets" to delete it.

```c++
#include <Rcpp.h>

using namespace Rcpp;

// [[Rcpp::export]]
NumericVector faulty_program(int n) {

    // Here is the faulty line
    NumericVector * x_ptr = new NumericVector(n);

    return *x_ptr;

}

/***R
# Calling the faulty program
faulty_program(10)
*/
```

We can use the `-e` flag in the `R` command to compile the `Rcpp` script using `sourceCpp`:

```bash
R --debugger=valgrind -e 'Rcpp::sourceCpp("rcpp-debugging-faulty.cpp")'
```

```{r}
#| echo: false
#| cache: true
#| output: asis
#| label: rcpp-debug-memleak
res <- system2(
    "R",
    "--debugger=valgrind -e 'Rcpp::sourceCpp(\"rcpp-debugging-faulty.cpp\")'",
    stdout = TRUE, stderr = TRUE
)

cat("```\n")
cat(res, sep = "\n")
cat("\n```\n")
```

By the end of the output, in the `LEAK SUMMARY` section, we see `definitely lost: 24 bytes in 1 block`, *i.e.*, a memory leak. If we change the program by deleting the pointer before returning, the leak will be solved:

::: {.columns}


::: {.column width="40%" layout-align="center"}
New program:
```cpp
    NumericVector res = *x_ptr;
    delete x_ptr;
    
    return res;
```
:::

::: {.column width="10%"}

:::

::: {.column width="40%" layout-align="center"}
Old program

```cpp    
    
    
    
    return *x_ptr;
```
:::

:::

Re-running R with Valgrind returns the following (only the last few lines):

```bash
R --debugger=valgrind -e 'Rcpp::sourceCpp("rcpp-debugging-faulty-fixed.cpp")'
```

```{r}
#| echo: false
#| cache: true
#| output: asis
#| label: rcpp-debug-memleak-fixed
res <- system2(
    "R",
    "--debugger=valgrind -e 'Rcpp::sourceCpp(\"rcpp-debugging-faulty-fixed.cpp\")'",
    stdout = TRUE,
    stderr = TRUE
    )

lastline <- which(grepl("^==[0-9]+==\\s*HEAP SUMMARY", res))
cat("```bash\n")
cat(res[lastline:length(res)], sep = "\n")
cat("\n```\n")
```

No more memory leaks. 


## Using GDB

Sometimes, we need to go further and inspect what's going on **inside** the program. GBD is excellent for that. With GBD, we can set breakpoints that allow us to review the program while it is executed. 

The following Rcpp code generates a `memory not mapped` type error:

```cpp
#include <Rcpp.h>

using namespace Rcpp;

// [[Rcpp::export]]
NumericVector faulty_program(int n) {

    // Here is the faulty line
    NumericVector * x_ptr;
        
    return *x_ptr;

}

/***R
# Calling the faulty program
faulty_program(10)
*/
```

In it, we try to access a location in the memory that hasn't been allocated yet, namely, a `NumericVector` declared as a pointer but never assigned. Using `R --debugger=valgrind` generates the following code:


```{r}
#| echo: false
#| cache: true
#| output: asis
#| label: rcpp-debug-not-mapped
#| warning: false
res <- suppressWarnings({system2(
    "R",
    "--debugger=valgrind -e 'Rcpp::sourceCpp(\"rcpp-debugging-not-mapped.cpp\")'",
    stdout = TRUE,
    stderr = TRUE
    )})

cat("```bash\n")
cat(res, sep = "\n")
cat("\n```\n")
```

To inspect an error with GDB, we have to follow these steps:

1. Run R with gdb as debugger: `R --debugger=gdb`. R won't start immediately, so we have time to add breakpoints.

    ![](fig/rcpp/rcpp-start-gdb.png){width="90%" fig-align="center"}

2. We can set a breakpoint on the given function with `break faulty_program`. GDB will grab it on the fly, so choose `yes`. It most likely will warn you that there's no symbol for that function.

    ![](fig/rcpp/rcpp-gdb-break.png){width="90%" fig-align="center"}

3. Run R using the `run` command in gdb:

    ![](fig/rcpp/rcpp-gdb-run.png){width="90%" fig-align="center"}

3. Source the program using `Rcpp::sourceCpp`, and wait for `gdb` to pause the program once it reaches the breakpoint.

    ![](fig/rcpp/rcpp-gdb-sourcecpp.png){width="90%" fig-align="center"}

4. Once the program has paused, we can inspect the context.

    ![](fig/rcpp/rcpp-gdb-pause-at-break.png){width="90%" fig-align="center"}

    Because of the number of options it has, using GBD can be overwhelming. Here is the list of commands I use the most:

    ```
    help        # Get help
    info locals # List the local variables (scope)
    info args   # List the arguments passed to the function
    list        # See the last few lines of the source code
    continue    # Continue running the program
    next        # Execute the next step
    bt          # Show the entire call stack (backtrace)
    up          # Go up one level in the call stack
    down        # Go down one level in the call stack
    print       # Print/display an expression
    ```

    And here is an example using `info locals`, `info args`, `list`, and `print`.

    ![](fig/rcpp/rcpp-gdb-info-list-print.png){width="90%" fig-align="center"}
